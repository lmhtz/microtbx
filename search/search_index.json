{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MicroTBX is an open source Microcontroller ToolBoX consisting of software components commonly needed in embedded software applications. Think of it as a Swiss army knife for your firmware. MicroTBX is written in the C programming language (C99). It currently supports all microcontrollers based on an ARM Cortex-M core, for example: ST STM32, Infineon XMC, and NXP S32K. There is little effort involved with porting MicroTBX to different microcontroller families. While developing MicroTBX, special care was given to making the code threadsafe. Access to shared resources are serialized with the help of critical sections . This make it safe to use MicroTBX in a multithreaded environment, for example when your embedded software program is built upon a pre-emptive RTOS. If you do not feel like reinventing the wheel, consider using MicroTBX. Ideally, MicroTBX is integrated into your embedded software program at the start of each new project. The following image illustrates where MicroTBX fits into your firmware's architecture: Components The following table presents an overview of the currently supported software components inside MicroTBX: Name Description Assertions For checking situations that should never happen. Critical Sections For mutual exclusive access to shared resources. Heap For static memory pre-allocation on the heap. Memory Pools For pool based dynamic memory allocation on the heap. Linked Lists For dynamically sized lists of data items. Random Numbers For generating random numbers. Checksums For calculating data checksums. Cryptography For data encryption and decryption. MISRA MicroTBX was developed with MISRA-C compliance in mind. This is a software development standard to facilitate best practices for programming safety-critical software in road vehicles and other embedded systems. Integration Adding MicroTBX to your software project is a simple four step process: Copy all the files from the source and the correct source\\port\\XXX port directory to your project. Configure your project such that the added .c files are compiled and linked during a build. Add the directories that contain the .h files to your compiler's include path. Customize the MicroTBX configuraton in tbx_conf.h , if desired. Usage Add the following line to each source-file, where you intend to make use of MicroTBX: #include \"microtbx.h\" Licensing MicroTBX is licensed under the MIT license . This permissive license enables you to include and distribute MicroTBX with your firmware, even if it is proprietary. The only requirements are that you include a copy of the MIT license and do not change the copyright notice, when you distribute MicroTBX.","title":"Home"},{"location":"#components","text":"The following table presents an overview of the currently supported software components inside MicroTBX: Name Description Assertions For checking situations that should never happen. Critical Sections For mutual exclusive access to shared resources. Heap For static memory pre-allocation on the heap. Memory Pools For pool based dynamic memory allocation on the heap. Linked Lists For dynamically sized lists of data items. Random Numbers For generating random numbers. Checksums For calculating data checksums. Cryptography For data encryption and decryption.","title":"Components"},{"location":"#misra","text":"MicroTBX was developed with MISRA-C compliance in mind. This is a software development standard to facilitate best practices for programming safety-critical software in road vehicles and other embedded systems.","title":"MISRA"},{"location":"#integration","text":"Adding MicroTBX to your software project is a simple four step process: Copy all the files from the source and the correct source\\port\\XXX port directory to your project. Configure your project such that the added .c files are compiled and linked during a build. Add the directories that contain the .h files to your compiler's include path. Customize the MicroTBX configuraton in tbx_conf.h , if desired.","title":"Integration"},{"location":"#usage","text":"Add the following line to each source-file, where you intend to make use of MicroTBX: #include \"microtbx.h\"","title":"Usage"},{"location":"#licensing","text":"MicroTBX is licensed under the MIT license . This permissive license enables you to include and distribute MicroTBX with your firmware, even if it is proprietary. The only requirements are that you include a copy of the MIT license and do not change the copyright notice, when you distribute MicroTBX.","title":"Licensing"},{"location":"apiref/","text":"This section provides a quick reference with the functions and macros that MicroTBX offers. Generic Macro Description TBX_VERSION_MAIN Main version number of MicroTBX. TBX_VERSION_MINOR Minor version number of MicroTBX. TBX_VERSION_PATCH Patch number of MicroTBX. TBX_TRUE Boolean true value. TBX_FALSE Boolean false value. TBX_OK Generic okay value. TBX_ERROR Generic error value. TBX_UNUSED_ARG() Function-like macro to flag a function parameter as unused. Assertions More information regarding this software component is found here . Macro Description TBX_ASSERT() Function-like macro to perform an assertion check. Function Description TbxAssertSetHandler() Register a custom assertion error handler. Critical Sections More information regarding this software component is found here . Function Description TbxCriticalSectionEnter() Enters a critical section. TbxCriticalSectionExit() Leaves a previously entered a critical section. Heap More information regarding this software component is found here . Function Description TbxHeapAllocate() Statically preallocates memory on the heap. TbxHeapGetFree() Reports how many bytes are still available on the heap. Memory Pools More information regarding this software component is found here . Function Description TbxMemPoolCreate() Creates or extends a memory pool of fixed sized blocks. TbxMemPoolAllocate() Dynamically allocates memory from a memory pool. TbxMemPoolRelease() Frees memory that was previously allocated from a memory pool. Linked Lists More information regarding this software component is found here . Function Description TbxListCreate() Create a new an empty linked list. TbxListDelete() Delete a previously created linked list. TbxListClear() Remove all items from the linked list. TbxListGetSize() Obtain the number of items stored in the linked list. TbxListInsertItem() Add a new item at the end of the linked list. TbxListInsertItemFront() Add a new item at the start of the linked list. TbxListRemoveItem() Remove an item from the linked list. TbxListGetFirstItem() Read the item at the start of the linked list. TbxListGetLastItem() Read the item at the end of the linked list. TbxListGetNextItem() Read the subsequent item from the linked list. TbxListGetPreviousItem() Read the preceding item from the linked list. TbxListSwapItems() Exchange two items in the linked list. TbxListSortItems() Sort the items in the linked list. Random Numbers More information regarding this software component is found here . Function Description TbxRandomNumberGet() Generate a 32-bit random number. TbxRandomSetSeedInitHandler() Register a custom seed initialization handler. Checksums More information regarding this software component is found here . Function Description TbxChecksumCrc16Calculate() Calculate the 16-bit CRC checksum over a block of data. TbxChecksumCrc32Calculate() Calculate the 32-bit CRC checksum over a block of data. Cryptography More information regarding this software component is found here . Function Description TbxCryptoAes256Encrypt() Performs AES encryption on a block of data using a 256-bit key. TbxCryptoAes256Decrypt() Performs AES decryption on a block of data using a 256-bit key.","title":"API Reference"},{"location":"apiref/#generic","text":"Macro Description TBX_VERSION_MAIN Main version number of MicroTBX. TBX_VERSION_MINOR Minor version number of MicroTBX. TBX_VERSION_PATCH Patch number of MicroTBX. TBX_TRUE Boolean true value. TBX_FALSE Boolean false value. TBX_OK Generic okay value. TBX_ERROR Generic error value. TBX_UNUSED_ARG() Function-like macro to flag a function parameter as unused.","title":"Generic"},{"location":"apiref/#assertions","text":"More information regarding this software component is found here . Macro Description TBX_ASSERT() Function-like macro to perform an assertion check. Function Description TbxAssertSetHandler() Register a custom assertion error handler.","title":"Assertions"},{"location":"apiref/#critical-sections","text":"More information regarding this software component is found here . Function Description TbxCriticalSectionEnter() Enters a critical section. TbxCriticalSectionExit() Leaves a previously entered a critical section.","title":"Critical Sections"},{"location":"apiref/#heap","text":"More information regarding this software component is found here . Function Description TbxHeapAllocate() Statically preallocates memory on the heap. TbxHeapGetFree() Reports how many bytes are still available on the heap.","title":"Heap"},{"location":"apiref/#memory-pools","text":"More information regarding this software component is found here . Function Description TbxMemPoolCreate() Creates or extends a memory pool of fixed sized blocks. TbxMemPoolAllocate() Dynamically allocates memory from a memory pool. TbxMemPoolRelease() Frees memory that was previously allocated from a memory pool.","title":"Memory Pools"},{"location":"apiref/#linked-lists","text":"More information regarding this software component is found here . Function Description TbxListCreate() Create a new an empty linked list. TbxListDelete() Delete a previously created linked list. TbxListClear() Remove all items from the linked list. TbxListGetSize() Obtain the number of items stored in the linked list. TbxListInsertItem() Add a new item at the end of the linked list. TbxListInsertItemFront() Add a new item at the start of the linked list. TbxListRemoveItem() Remove an item from the linked list. TbxListGetFirstItem() Read the item at the start of the linked list. TbxListGetLastItem() Read the item at the end of the linked list. TbxListGetNextItem() Read the subsequent item from the linked list. TbxListGetPreviousItem() Read the preceding item from the linked list. TbxListSwapItems() Exchange two items in the linked list. TbxListSortItems() Sort the items in the linked list.","title":"Linked Lists"},{"location":"apiref/#random-numbers","text":"More information regarding this software component is found here . Function Description TbxRandomNumberGet() Generate a 32-bit random number. TbxRandomSetSeedInitHandler() Register a custom seed initialization handler.","title":"Random Numbers"},{"location":"apiref/#checksums","text":"More information regarding this software component is found here . Function Description TbxChecksumCrc16Calculate() Calculate the 16-bit CRC checksum over a block of data. TbxChecksumCrc32Calculate() Calculate the 32-bit CRC checksum over a block of data.","title":"Checksums"},{"location":"apiref/#cryptography","text":"More information regarding this software component is found here . Function Description TbxCryptoAes256Encrypt() Performs AES encryption on a block of data using a 256-bit key. TbxCryptoAes256Decrypt() Performs AES decryption on a block of data using a 256-bit key.","title":"Cryptography"},{"location":"assertions/","text":"Assertions are statements used for checking situations that should never happen. It is a good coding practice to add such statements to your software program. For example to validate the values of function parameters, to check pointers for not being NULL, to check that an array index is not out of range, etc. Usage In MicroTBX, assertions are implemented with the TBX_ASSERT(argument) macro. The argument must evaluate to boolean true for the program to continue its execution as expected. If the argument evaluates to boolean false , an error is triggered. In this error case, MicroTBX jumps to an internal function with an infinite loop to hang the program. This function is called with two important parameters for debugging purposes: the filename of the source file that caused the assertion to fail and the line number inside this file where the assertion occurred. Practically, this means that when debugging and testing your software program, you simply set a breakpoint inside the internal function TbxAssertTrigger() . If an assertion is triggered, the debugger stops at the breakpoint. At this point you can inspect the function parameters file and line to determine which assertion statement caused the problem. Once you know the root cause of the assertion error, you can start working on a solution to fix the problem from happening in the future. In case you do not like the default assertion error handling, MicroTBX also makes it possible for you to configure your own assertion handler with function TbxAssertSetHandler() . For example to execute a printf statement, to turn on an LED, or to write assertion error info to a file an on SD-card to indicate that an assertion error was detected. Examples The following example demonstrates how assertions can be used to test that a function parameter has a valid value range: uint8_t myArray[4] = { 1, 2, 3, 4 }; void IncrementArrayElement(int8_t index) { /* Make sure the array index is positive. */ TBX_ASSERT(index >= 0); /* Make sure the array index is not out of range. */ TBX_ASSERT(index < (sizeof(myArray)/sizeof(myArray[0]))); /* Increment the array element at the requested index. */ myArray[index]++; } The next example shows how you can register your own assertion error handler, which overrides the internal error handling: #include <stdio.h> void MyAssertionHandler(const char * const file, uint32_t line) { /* Display the assertion error info. */ printf(\"[ERROR] Assertion in %s at line %lu\", file, line); } int main(void) { /* Register the application specific assertion handler. */ TbxAssertSetHandler(MyAssertionHandler); /* TODO Implement your program here. */ return 0; } Configuration The enable the assertion error handling, set the macro TBX_CONF_ASSERTIONS_ENABLE to a value of 1 : /** \\brief Enable/disable run-time assertions. */ #define TBX_CONF_ASSERTIONS_ENABLE (1U) To disable the assertion error handling, set this macro to a value of 0 . Note that there is not need to remove the TBX_ASSERT() macros from your code. MicroTBX automatically makes the TBX_ASSERT() macro and empty macro without side effect, when assertion error handling was disabled. Assertions are typically enabled in a debug version of the software program and disabled in a release version of the software program. Extra tips Make sure to write your assertion statements such that you do not accidentally remove functionality from your software program, after disabling the assertion error handling. So instead of the following: FATFS fs; void MountDrive(void) { /* Mount the drive and make sure the drive mounting succeeded. */ TBX_ASSERT(f_mount(&fs, \"0:\", 0) == FR_OK); } Do the following: FATFS fs; void MountDrive(void) { FRESULT fresult; /* Mount the drive. */ fresult = f_mount(&fs, \"0:\", 0); /* Make sure the drive mounting succeeded. */ TBX_ASSERT(fresult == FR_OK); } To be sure that the before mentioned problem does not occur, one could make the argument that assertion error handling should simply never be disabled.","title":"Assertions"},{"location":"assertions/#usage","text":"In MicroTBX, assertions are implemented with the TBX_ASSERT(argument) macro. The argument must evaluate to boolean true for the program to continue its execution as expected. If the argument evaluates to boolean false , an error is triggered. In this error case, MicroTBX jumps to an internal function with an infinite loop to hang the program. This function is called with two important parameters for debugging purposes: the filename of the source file that caused the assertion to fail and the line number inside this file where the assertion occurred. Practically, this means that when debugging and testing your software program, you simply set a breakpoint inside the internal function TbxAssertTrigger() . If an assertion is triggered, the debugger stops at the breakpoint. At this point you can inspect the function parameters file and line to determine which assertion statement caused the problem. Once you know the root cause of the assertion error, you can start working on a solution to fix the problem from happening in the future. In case you do not like the default assertion error handling, MicroTBX also makes it possible for you to configure your own assertion handler with function TbxAssertSetHandler() . For example to execute a printf statement, to turn on an LED, or to write assertion error info to a file an on SD-card to indicate that an assertion error was detected.","title":"Usage"},{"location":"assertions/#examples","text":"The following example demonstrates how assertions can be used to test that a function parameter has a valid value range: uint8_t myArray[4] = { 1, 2, 3, 4 }; void IncrementArrayElement(int8_t index) { /* Make sure the array index is positive. */ TBX_ASSERT(index >= 0); /* Make sure the array index is not out of range. */ TBX_ASSERT(index < (sizeof(myArray)/sizeof(myArray[0]))); /* Increment the array element at the requested index. */ myArray[index]++; } The next example shows how you can register your own assertion error handler, which overrides the internal error handling: #include <stdio.h> void MyAssertionHandler(const char * const file, uint32_t line) { /* Display the assertion error info. */ printf(\"[ERROR] Assertion in %s at line %lu\", file, line); } int main(void) { /* Register the application specific assertion handler. */ TbxAssertSetHandler(MyAssertionHandler); /* TODO Implement your program here. */ return 0; }","title":"Examples"},{"location":"assertions/#configuration","text":"The enable the assertion error handling, set the macro TBX_CONF_ASSERTIONS_ENABLE to a value of 1 : /** \\brief Enable/disable run-time assertions. */ #define TBX_CONF_ASSERTIONS_ENABLE (1U) To disable the assertion error handling, set this macro to a value of 0 . Note that there is not need to remove the TBX_ASSERT() macros from your code. MicroTBX automatically makes the TBX_ASSERT() macro and empty macro without side effect, when assertion error handling was disabled. Assertions are typically enabled in a debug version of the software program and disabled in a release version of the software program.","title":"Configuration"},{"location":"assertions/#extra-tips","text":"Make sure to write your assertion statements such that you do not accidentally remove functionality from your software program, after disabling the assertion error handling. So instead of the following: FATFS fs; void MountDrive(void) { /* Mount the drive and make sure the drive mounting succeeded. */ TBX_ASSERT(f_mount(&fs, \"0:\", 0) == FR_OK); } Do the following: FATFS fs; void MountDrive(void) { FRESULT fresult; /* Mount the drive. */ fresult = f_mount(&fs, \"0:\", 0); /* Make sure the drive mounting succeeded. */ TBX_ASSERT(fresult == FR_OK); } To be sure that the before mentioned problem does not occur, one could make the argument that assertion error handling should simply never be disabled.","title":"Extra tips"},{"location":"checksum/","text":"A checksum is an integer value that can verify the contents of a data block. In embedded software programs, the common purposes of a checksum are: to validate the contents of a data bock, and to detect accidental changes in a data block. A checksum could for example be calculated over the entire program code that is programmed into flash memory. The checksum could then stored at another location in flash memory, with the help of the debugger / flash programmer. At program startup, the initialization code could recalculate the checksum and compare it with the value programmed by the debugger / flash programmer. It the values do not match, you can conclude that somehow the flash contents got changed and the software program might not execute properly. Checksums are also often embedded in communication data streams. The sender calculates and adds the checksum to the communication data. Upon reception, the receiver recalculates the checksum and compares the calculated value with the value that was added by the sender. The communication data is deemed valid if both values match. Usage MicroTBX includes functionality to calculate both 16-bit and 32-bit checksum values over a fixed length byte array, using a cyclic redundancy check (CRC) algorithm. To calculate the 16-bit checksum value over a number of bytes, function TbxChecksumCrc16Calculate() is available. In case a 32-bit checksum value is preferred, function TbxChecksumCrc32Calculate() can be called. Examples The following example declares a data block with communication data, consisting of 32 bytes (8 * 4). Function CalculateChecksum() demonstrates how a 32-bit checksum over the communication data is calculated. The sender of this data packet could send the checksum value together with the actual packet data. The receiver could read out the received packet data and packet checksum value. Next, it calls function VerifyChecksum() to check if the packet data is valid and no bits got changed during the communication transfer. uint32_t communicationData[8] = { 0x8ef9c15f, 0x4323a3cb, 0xb12ba488, 0xb3f5ec04, 0xc1c7544f, 0x4140ec9d, 0xc5dd421a, 0x14d57e3d }; uint32_t CalculateChecksum(void) { uint8_t result; uint8_t * dataPtr; size_t dataLen; /* Collect data block settings. */ dataPtr = (uint8_t *)&communicationData[0]; dataLen = sizeof(communicationData)/sizeof(uint8_t); /* Calculate the checksum. */ result = TbxChecksumCrc32Calculate(dataPtr, dataLen); /* Return the result. */ return result; } uint8_t VerifyChecksum(uint32_t checksum) { uint8_t result = TBX_FALSE; uint32_t calculatedChecksum; /* Recalculate the checksum. */ calculatedChecksum = CalculateChecksum(); /* Verify that the data contents are still valid. */ if (calculatedChecksum == checksum) { result = TBX_TRUE; } /* Return the result. */ return result; } Configuration The 16-bit and 32-bit CRC algorithms uses a specific polynomial value and are seeded with an initial value. The default configuration of these values work fine and there is no need to change these. If for some reason your application requires you to set different values for the initial and polynomial values, you can override the default configuration by adding the following macros to the tbx_conf.h configuration file and assign the values you prefer: /** \\brief Polynomial of the 16-bit CRC. */ #define TBX_CONF_CHECKSUM_CRC16_POLYNOM (0x8005U) /** \\brief Initial value of the 6-bit CRC calculation. */ #define TBX_CONF_CHECKSUM_CRC16_INITIAL (0x0000U) /** \\brief Polynomial of the 32-bit CRC. */ #define TBX_CONF_CHECKSUM_CRC32_POLYNOM (0x04C11DB7UL) /** \\brief Initial value of the 32-bit CRC calculation. */ #define TBX_CONF_CHECKSUM_CRC32_INITIAL (0x00000000UL)","title":"Checksums"},{"location":"checksum/#usage","text":"MicroTBX includes functionality to calculate both 16-bit and 32-bit checksum values over a fixed length byte array, using a cyclic redundancy check (CRC) algorithm. To calculate the 16-bit checksum value over a number of bytes, function TbxChecksumCrc16Calculate() is available. In case a 32-bit checksum value is preferred, function TbxChecksumCrc32Calculate() can be called.","title":"Usage"},{"location":"checksum/#examples","text":"The following example declares a data block with communication data, consisting of 32 bytes (8 * 4). Function CalculateChecksum() demonstrates how a 32-bit checksum over the communication data is calculated. The sender of this data packet could send the checksum value together with the actual packet data. The receiver could read out the received packet data and packet checksum value. Next, it calls function VerifyChecksum() to check if the packet data is valid and no bits got changed during the communication transfer. uint32_t communicationData[8] = { 0x8ef9c15f, 0x4323a3cb, 0xb12ba488, 0xb3f5ec04, 0xc1c7544f, 0x4140ec9d, 0xc5dd421a, 0x14d57e3d }; uint32_t CalculateChecksum(void) { uint8_t result; uint8_t * dataPtr; size_t dataLen; /* Collect data block settings. */ dataPtr = (uint8_t *)&communicationData[0]; dataLen = sizeof(communicationData)/sizeof(uint8_t); /* Calculate the checksum. */ result = TbxChecksumCrc32Calculate(dataPtr, dataLen); /* Return the result. */ return result; } uint8_t VerifyChecksum(uint32_t checksum) { uint8_t result = TBX_FALSE; uint32_t calculatedChecksum; /* Recalculate the checksum. */ calculatedChecksum = CalculateChecksum(); /* Verify that the data contents are still valid. */ if (calculatedChecksum == checksum) { result = TBX_TRUE; } /* Return the result. */ return result; }","title":"Examples"},{"location":"checksum/#configuration","text":"The 16-bit and 32-bit CRC algorithms uses a specific polynomial value and are seeded with an initial value. The default configuration of these values work fine and there is no need to change these. If for some reason your application requires you to set different values for the initial and polynomial values, you can override the default configuration by adding the following macros to the tbx_conf.h configuration file and assign the values you prefer: /** \\brief Polynomial of the 16-bit CRC. */ #define TBX_CONF_CHECKSUM_CRC16_POLYNOM (0x8005U) /** \\brief Initial value of the 6-bit CRC calculation. */ #define TBX_CONF_CHECKSUM_CRC16_INITIAL (0x0000U) /** \\brief Polynomial of the 32-bit CRC. */ #define TBX_CONF_CHECKSUM_CRC32_POLYNOM (0x04C11DB7UL) /** \\brief Initial value of the 32-bit CRC calculation. */ #define TBX_CONF_CHECKSUM_CRC32_INITIAL (0x00000000UL)","title":"Configuration"},{"location":"critsect/","text":"In an interrupt driven embedded software program, problems can occur with global resource sharing. A global resource can for example be a global data structure, a peripheral, or a communication device. Imagine a situation where the software program is writing to a global variable and before the write operation is completed, an interrupt occured. The associated interrupt handler could write to the same global variable. After the interrupt is completed, to initial write operation completes. The global variable now holds invalid data. Such data concurrency issues are resolved by performing the global resource access in a critical section. In a critical section, no interrupt can occur and you can therefore be certain that you have mutual exlusive access to the global resource. Usage In MicroTBX a critical section is entered by calling the function TbxCriticalSectionEnter() . After this the global resource can be safely accessed. Once done, the critical section is left by calling the function TbxCriticalSectionExit() . This means that both functions must always be used pair-wise. Each call to TbxCriticalSectionEnter() must eventually be followed by a call to TbxCriticalSectionExit() . Note that MicroTBX supports nested critical sections. It is completely fine if your software program enters the critical section again, even if it is already in a critical section. Examples The following example contains a global variable myMessage and a function TransmitMessage() . Imagine that this function can be called both from the main program loop and from an interrupt. This makes variable myMessage a shared resource. A critical section is applied to obtain mutual exclusive access to the variable myMessage : struct { uint32_t id; uint8_t len; uint8_t data[8]; } myMessage; void TransmitMessage(void) { /* Obtain mutual exclusive access to myMessage. */ TbxCriticalSectionEnter(); /* Prepare and send the message. */ myMessage.id++; myMessage.len = 1u; myMessage.data[0]++; SendMessage(&myMessage); /* Release mutual exclusive access to myMessage. */ TbxCriticalSectionExit(); }","title":"Critical Sections"},{"location":"critsect/#usage","text":"In MicroTBX a critical section is entered by calling the function TbxCriticalSectionEnter() . After this the global resource can be safely accessed. Once done, the critical section is left by calling the function TbxCriticalSectionExit() . This means that both functions must always be used pair-wise. Each call to TbxCriticalSectionEnter() must eventually be followed by a call to TbxCriticalSectionExit() . Note that MicroTBX supports nested critical sections. It is completely fine if your software program enters the critical section again, even if it is already in a critical section.","title":"Usage"},{"location":"critsect/#examples","text":"The following example contains a global variable myMessage and a function TransmitMessage() . Imagine that this function can be called both from the main program loop and from an interrupt. This makes variable myMessage a shared resource. A critical section is applied to obtain mutual exclusive access to the variable myMessage : struct { uint32_t id; uint8_t len; uint8_t data[8]; } myMessage; void TransmitMessage(void) { /* Obtain mutual exclusive access to myMessage. */ TbxCriticalSectionEnter(); /* Prepare and send the message. */ myMessage.id++; myMessage.len = 1u; myMessage.data[0]++; SendMessage(&myMessage); /* Release mutual exclusive access to myMessage. */ TbxCriticalSectionExit(); }","title":"Examples"},{"location":"crypto/","text":"The cryptography software component contains functionality to encrypt and decrypt data blocks. Encryption essentially changes the data contents such that its contents can no longer be interpreted by unwanted third parties. Only the party that has access to the so called key, with which the data was encrypted, can decrypt the data contents back into its original state. Encryption enables you to securely protect data that you don't want anyone else to have access to. Possible fields of application in an embedded software program are: securing communication data, securing parameters or other proprietary data stored in EEPROM, etc. The cryptography software component is based on 256-bit AES ECB. AES stands for Advanced Encryption Standard and ECB stands for Electronic CodeBook. The key needed to perform the actual encryption and decryption is 256-bit in size. In C code, this is an array of 32 bytes. The only restriction is that the data to encrypt or decrypt must always be a multiple of 16 bytes in size. If this is not the case, the data needs to be aligned to a multiple of 16 bytes prior to performing the encryption/decryption operation. Usage The first step is to define your 256-bit cryptography key. This is nothing more than an array of 32 bytes. You can decide on the contents yourself. The only important part to remember is that you need the same key for both the encryption and decryption steps, in order to get the original data back when decrypting the encrypted data. Here is an example of how to define a cryptography key in C: /* The 256-bit key that will be used to encrypt and decrypt data. */ const uint8_t cryptoKey[32] = { 0x32, 0x72, 0x35, 0x75, 0x38, 0x78, 0x21, 0x41, 0x25, 0x44, 0x2A, 0x47, 0x2D, 0x4B, 0x61, 0x50, 0x64, 0x53, 0x67, 0x56, 0x6B, 0x59, 0x70, 0x33, 0x73, 0x36, 0x76, 0x39, 0x79, 0x24, 0x42, 0x3F }; Note that you can use an encryption key generator to assist with getting unique contents for your cryptography key. To encrypt a 16-byte aligned data block, the function TbxCryptoAes256Encrypt() is available. To decrypt the data block back to its original state, the function TbxCryptoAes256Decrypt() can be called. Examples The following code example first encrypts the contents of a data buffer. Afterwards, the encrypted data is decrypted again. Followed by a verification to test that the decrypted data actually resembles the original data. The cryptoKey[] presented above serves as the 256-bit cryptography key: /* Original data. */ const uint8_t originalData[64] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F }; /* Temporary buffer to storing the encrypted/decrypted data. */ uint8_t buffer[64]; /* Array indexer for looping through array data. */ size_t idx; /* Copy the original data to the buffer. */ for (idx = 0U; idx < 64U; idx++) { buffer[idx] = originalData[idx]; } /* Encrypt the data in the buffer. */ TbxCryptoAes256Encrypt(buffer, 64, cryptoKey); /* Decrypt the data in the buffer. */ TbxCryptoAes256Decrypt(buffer, 64, cryptoKey); /* Verify that the decrypted data is the same as the original data. */ for (idx = 0U; idx < 64U; idx++) { if (buffer[idx] != originalData[idx]) { TBX_ASSERT(TBX_ERROR); } }","title":"Cryptography"},{"location":"crypto/#usage","text":"The first step is to define your 256-bit cryptography key. This is nothing more than an array of 32 bytes. You can decide on the contents yourself. The only important part to remember is that you need the same key for both the encryption and decryption steps, in order to get the original data back when decrypting the encrypted data. Here is an example of how to define a cryptography key in C: /* The 256-bit key that will be used to encrypt and decrypt data. */ const uint8_t cryptoKey[32] = { 0x32, 0x72, 0x35, 0x75, 0x38, 0x78, 0x21, 0x41, 0x25, 0x44, 0x2A, 0x47, 0x2D, 0x4B, 0x61, 0x50, 0x64, 0x53, 0x67, 0x56, 0x6B, 0x59, 0x70, 0x33, 0x73, 0x36, 0x76, 0x39, 0x79, 0x24, 0x42, 0x3F }; Note that you can use an encryption key generator to assist with getting unique contents for your cryptography key. To encrypt a 16-byte aligned data block, the function TbxCryptoAes256Encrypt() is available. To decrypt the data block back to its original state, the function TbxCryptoAes256Decrypt() can be called.","title":"Usage"},{"location":"crypto/#examples","text":"The following code example first encrypts the contents of a data buffer. Afterwards, the encrypted data is decrypted again. Followed by a verification to test that the decrypted data actually resembles the original data. The cryptoKey[] presented above serves as the 256-bit cryptography key: /* Original data. */ const uint8_t originalData[64] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F }; /* Temporary buffer to storing the encrypted/decrypted data. */ uint8_t buffer[64]; /* Array indexer for looping through array data. */ size_t idx; /* Copy the original data to the buffer. */ for (idx = 0U; idx < 64U; idx++) { buffer[idx] = originalData[idx]; } /* Encrypt the data in the buffer. */ TbxCryptoAes256Encrypt(buffer, 64, cryptoKey); /* Decrypt the data in the buffer. */ TbxCryptoAes256Decrypt(buffer, 64, cryptoKey); /* Verify that the decrypted data is the same as the original data. */ for (idx = 0U; idx < 64U; idx++) { if (buffer[idx] != originalData[idx]) { TBX_ASSERT(TBX_ERROR); } }","title":"Examples"},{"location":"heap/","text":"In an embedded software program, memory can be dynamically allocated. The heap is available for this, which is a part of RAM specifically reserved for dynamically allocated memory. The C standard library offers the functions malloc() and free() for allocating and releasing memory on the heap. Both functions treat the heap as a byte pool, which means there is always a fragmentation risk present. The fragmentation eventually leads to a situation where memory can no longer be allocated, resulting in lost functionality or a crash of the software program in the worst case. This fragmentation risk is therefore unacceptable and another solution needs to be found for handling dynamic allocation. The solution is two-fold: Use static memory preallocation. This entails performing the memory allocation once during software program initialization and never releasing (free-ing) the allocated memory. This means that the lifetime of the allocated data spans the run-time of the entire software program. Use memory pools. With a memory pool, memory is allocated as fixed-size memory blocks (partitions). The benefit of dynamic memory allocation using memory pools is that the memory can be released again without the before mentioned fragmentation risk. It is perfect in situations when temporary data storage is needed, and the lifetime of the data is longer than just one function. MicroTBX offers software components for both solutions. The heap software component described in this section covers solution (1) with static memory preallocation. The memory pools software component covers solution (2). Usage The heap software component offers the function TbxHeapAllocate() for performing memory allocation on the heap. Because it is meant for static memory preallocation only, there is no function for free-ing the allocated memory. The idea is that function TbxHeapAllocate() is only called during the initialization of the software program, so before the infinite program loop is entered. It is basically its own implementation of malloc() , without free() . To find out how many bytes of memory are still available on the heap, function TbxHeapGetFree() can be called. If a software program has a need to allocate and release memory during the infinite program loop, the memory allocation should be performed with the functionality present in the memory pools software component. Examples The following example demonstrates how to call the functions of the heap software component. Memory for a FIFO buffer is preallocated during the software program initialization. /* A first-in first-out buffer of 32-bit values. */ uint32_t * fifoBuffer = NULL; uint32_t const fifoMaxSize = 32; uint8_t fifoIdx; /* Make sure there is enough space on the heap for the FIFO buffer. */ if (TbxHeapGetFree() < (fifoMaxSize * sizeof(uint32_t))) { TBX_ASSERT(TBX_FALSE); } /* Perform static preallocation of the FIFO buffer. */ fifoBuffer = TbxHeapAllocate(fifoMaxSize * sizeof(uint32_t)); /* Make sure the allocation was successful. */ TBX_ASSERT(fifoBuffer != NULL); /* Initialize the FIFO buffer. */ for (fifoIdx = 0; fifoIdx < fifoMaxSize; fifoIdx++) { fifoBuffer[fifoIdx] = 0; } Configuration The maximum size of the heap is configured with macro TBX_CONF_HEAP_SIZE : /** \\brief Configure the size of the heap in bytes. */ #define TBX_CONF_HEAP_SIZE (2048U)","title":"Heap"},{"location":"heap/#usage","text":"The heap software component offers the function TbxHeapAllocate() for performing memory allocation on the heap. Because it is meant for static memory preallocation only, there is no function for free-ing the allocated memory. The idea is that function TbxHeapAllocate() is only called during the initialization of the software program, so before the infinite program loop is entered. It is basically its own implementation of malloc() , without free() . To find out how many bytes of memory are still available on the heap, function TbxHeapGetFree() can be called. If a software program has a need to allocate and release memory during the infinite program loop, the memory allocation should be performed with the functionality present in the memory pools software component.","title":"Usage"},{"location":"heap/#examples","text":"The following example demonstrates how to call the functions of the heap software component. Memory for a FIFO buffer is preallocated during the software program initialization. /* A first-in first-out buffer of 32-bit values. */ uint32_t * fifoBuffer = NULL; uint32_t const fifoMaxSize = 32; uint8_t fifoIdx; /* Make sure there is enough space on the heap for the FIFO buffer. */ if (TbxHeapGetFree() < (fifoMaxSize * sizeof(uint32_t))) { TBX_ASSERT(TBX_FALSE); } /* Perform static preallocation of the FIFO buffer. */ fifoBuffer = TbxHeapAllocate(fifoMaxSize * sizeof(uint32_t)); /* Make sure the allocation was successful. */ TBX_ASSERT(fifoBuffer != NULL); /* Initialize the FIFO buffer. */ for (fifoIdx = 0; fifoIdx < fifoMaxSize; fifoIdx++) { fifoBuffer[fifoIdx] = 0; }","title":"Examples"},{"location":"heap/#configuration","text":"The maximum size of the heap is configured with macro TBX_CONF_HEAP_SIZE : /** \\brief Configure the size of the heap in bytes. */ #define TBX_CONF_HEAP_SIZE (2048U)","title":"Configuration"},{"location":"license/","text":"MicroTBX is released under the MIT license. This permissive license enables you to include and distribute MicroTBX with your firmware, even if it is proprietary. Refer to the following table for answers to frequently asked questions regarding the MIT license. Question MIT license Is MicroTBX free? yes Do I have the right to change the MicroTBX source code? yes Can I use MicroTBX in my closed source product? yes Do I have to open my source code? no Do I have to open source my changes to MicroTBX? no Do I have to offer the MicroTBX source code to users of my product? no Do I have to document that my product uses MicroTBX? no Can I redistribute MicroTBX in source code format? yes Can I receive professional technical support on a commercial basis? yes The actual license text is as follows: /*--------------------------------------------------------------------------------------- * C O P Y R I G H T *---------------------------------------------------------------------------------------- * Copyright (c) 2019 by Feaser www.feaser.com All rights reserved * *---------------------------------------------------------------------------------------- * L I C E N S E *---------------------------------------------------------------------------------------- * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */","title":"Licensing"},{"location":"lists/","text":"This software component consists of an easy-to-use set of functions for managing and sorting items in a linked list. It builds upon the memory pool functionality, which makes is possible to dynamically create, delete and automatically grow linked lists in a convenient way. Think of a linked list as an array on steroids. You do not yet have to know its size upon creation and you can insert, remove and sort its items with ease. A linked list is a sequence of data items, where each data item contains a connection to the adjacent items. In this software component the definition of a data item is a pointer to the data. The only thing you as the programmer need to take care of, is that the data pointer actually points to valid data before inserting it into the linked list. Linked lists are commonly used data structures in software programs and they are perfect for scenarios where you need to store a sequence of data, but you do not yet know the maximum number of items to store ahead of time. An example would be a first-in-first-out (FIFO) buffer. Usage Linked list can be created and deleted at any time in the software program with functions TbxListCreate() and TbxListDelete() . The TbxListCreate() function returns a pointer to the new list. This list pointer serves as a handle to the list. You can pass this handle as a parameter to all the other functions in the software component to identify the list that should be operated on. Once the list is created, you can start adding items to the list with functions TbxListInsertItemFront() , TbxListInsertItemBack() , TbxListInsertItemBefore() , and TbxListInsertItemAfter() . The function to call depends on where in the list you would like to add the item. For reading items and for iterating over items, the functions TbxListGetFirstItem() , TbxListGetLastItem() , TbxListGetPreviousItem() , and TbxListGetNextItem() are available. At any given time, you can obtain the number of items that are stored in the list with function TbxListGetSize() . Call function TbxListRemoveItem() to remove a single item from the list, or call TbxListClear() to remove all items at once. For editing the order of the items in the list, functions TbxListSwapItems() and TbxListSortItems() are available. When calling TbxListSortItems() you can specify your own function that will be called during the sort operation. In this callback function you can implement your own application specific logic for comparing two data items, therefore giving you full control and flexibility over how the sorting works. Examples This section contains a few examples to demonstrate how the linked list software component works. To keep the examples simple, some error checking of function return values was omitted. The examples assume that the following type for an arbitrary message is defined: typedef struct { uint32_t id; uint8_t len; uint8_t data[8]; } tMsg; Example 1 The first example demonstrates how quickly a first-in-first-out (FIFO) buffer can be created. Keep in mind that a linked list holds pointers to data items. It is up to the developer to allocate and release the memory for the data item. Luckily, this is easy with the help of a memory pool . tTbxList * msgBuffer; void MsgBufferInit(void) { /* Create the linked list. */ msgBuffer = TbxListCreate(); /* Create message memory pool with an initial size of 1. */ TbxMemPoolCreate(1, sizeof(tMsg)); } void MsgBufferAdd(tMsg const * msg) { tMsg * newMsg; /* Attempt to allocate memory to store the message. */ newMsg = TbxMemPoolAllocate(sizeof(tMsg)); /* Automatically increase the memory pool if it was too small. */ if (newMsg == NULL) { TbxMemPoolCreate(1, sizeof(tMsg)); newMsg = TbxMemPoolAllocate(sizeof(tMsg)); } /* Copy the message. */ *newMsg = *msg; /* Add the message at the end of the list. */ TbxListInsertItemBack(msgBuffer, newMsg); } uint8_t MsgBufferGet(tMsg * msg) { uint8_t result = TBX_ERROR; tMsg * oldMsg; uint8_t idx; /* Get the oldest message from the list, if any. */ oldMsg = TbxListGetFirstItem(msgBuffer); if (oldMsg != NULL) { /* Delete it from the list now that we read it. */ TbxListRemoveItem(msgBuffer, oldMsg); /* Copy the message contents. */ *msg = *oldMsg; /* Give the allocated memory for the message back to the pool. */ TbxMemPoolRelease(oldMsg); /* Update the result. */ result = TBX_OK; } return result; } You now not only have a FIFO buffer for storing messages, but its implementation is such that it can automatically grow in size. Memory pools form the foundation for this, meaning that you do not have to worry about memory fragmentation. The following code demonstrates how messages can be stored and retrieved from this FIFO buffer: /* Initialize the message FIFO buffer. */ MsgBufferInit(); /* Add a few messages. */ tMsg newMsg1 = { 0x200, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; tMsg newMsg2 = { 0x300, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; tMsg newMsg3 = { 0x100, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; MsgBufferAdd(&newMsg1); MsgBufferAdd(&newMsg2); MsgBufferAdd(&newMsg3); /* Extract messages from the FIFO buffer. */ tMsg msg; while (MsgBufferGet(&msg) == TBX_OK) { printf(\" Item ID: 0x%x\\n\", msg.id); } After running this code, the following is shown: Item ID: 0x200 Item ID: 0x300 Item ID: 0x100 Example 2 The second example demonstrates how to iterate through contents of a linked list. The following function prints information about the list contents: void MsgBufferPrint(void) { tMsg * msg; size_t cnt = 0; printf(\"Number of items: %d\\n\", TbxListGetSize(msgBuffer)); msg = TbxListGetFirstItem(msgBuffer); while (msg != NULL) { printf(\" Item %d ID: 0x%x\\n\", ++cnt, msg->id); msg = TbxListGetNextItem(msgBuffer, msg); } } After running this example code: /* Initialize the message FIFO buffer. */ MsgBufferInit(); /* Add a few messages. */ tMsg newMsg1 = { 0x200, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; tMsg newMsg2 = { 0x300, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; tMsg newMsg3 = { 0x100, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; MsgBufferAdd(&newMsg1); MsgBufferAdd(&newMsg2); MsgBufferAdd(&newMsg3); /* Print current FIFO buffer contents. */ MsgBufferPrint(); The following is shown: Number of items: 3 Item 1 ID: 0x200 Item 2 ID: 0x300 Item 3 ID: 0x100 Example 3 The third example builds upon example 2, where there are three messages in the list. Let's assume you want to sort the list contents based on the message identifier. For this you could implement the following function for comparing two messages: uint8_t CompareMessage(void const * item1, void const * item2) { uint8_t result = TBX_FALSE; tMsg const * msg1 = item1; tMsg const * msg2 = item2; if (msg1->id > msg2->id) { result = TBX_TRUE; } return result; } To perform the actual sort operation, you could run this code: /* Print FIFO buffer contents before sorting. */ printf(\"--- Before sorting ---\\n\"); MsgBufferPrint(); /* Sort the buffer based on the message identifier. */ TbxListSortItems(msgBuffer, CompareMessage); /* Print FIFO buffer contents after sorting. */ printf(\"--- After sorting ---\\n\"); MsgBufferPrint(); The following is shown: --- Before sorting --- Number of items: 3 Item 1 ID: 0x200 Item 2 ID: 0x300 Item 3 ID: 0x100 --- After sorting --- Number of items: 3 Item 1 ID: 0x100 Item 2 ID: 0x200 Item 3 ID: 0x300 Note that the items in the list are now sorted based on the message identifier in ascending order. Configuration The linked list software component itself does not have to be configured. However, when creating a linked list and inserting items into it, the memory needed is dynamically allocated with the help of a memory pool. Because a memory pool takes memory from the heap, make sure the heap size is configured large enough with the help of macro TBX_CONF_HEAP_SIZE : /** \\brief Configure the size of the heap in bytes. */ #define TBX_CONF_HEAP_SIZE (2048U)","title":"Linked Lists"},{"location":"lists/#usage","text":"Linked list can be created and deleted at any time in the software program with functions TbxListCreate() and TbxListDelete() . The TbxListCreate() function returns a pointer to the new list. This list pointer serves as a handle to the list. You can pass this handle as a parameter to all the other functions in the software component to identify the list that should be operated on. Once the list is created, you can start adding items to the list with functions TbxListInsertItemFront() , TbxListInsertItemBack() , TbxListInsertItemBefore() , and TbxListInsertItemAfter() . The function to call depends on where in the list you would like to add the item. For reading items and for iterating over items, the functions TbxListGetFirstItem() , TbxListGetLastItem() , TbxListGetPreviousItem() , and TbxListGetNextItem() are available. At any given time, you can obtain the number of items that are stored in the list with function TbxListGetSize() . Call function TbxListRemoveItem() to remove a single item from the list, or call TbxListClear() to remove all items at once. For editing the order of the items in the list, functions TbxListSwapItems() and TbxListSortItems() are available. When calling TbxListSortItems() you can specify your own function that will be called during the sort operation. In this callback function you can implement your own application specific logic for comparing two data items, therefore giving you full control and flexibility over how the sorting works.","title":"Usage"},{"location":"lists/#examples","text":"This section contains a few examples to demonstrate how the linked list software component works. To keep the examples simple, some error checking of function return values was omitted. The examples assume that the following type for an arbitrary message is defined: typedef struct { uint32_t id; uint8_t len; uint8_t data[8]; } tMsg;","title":"Examples"},{"location":"lists/#example-1","text":"The first example demonstrates how quickly a first-in-first-out (FIFO) buffer can be created. Keep in mind that a linked list holds pointers to data items. It is up to the developer to allocate and release the memory for the data item. Luckily, this is easy with the help of a memory pool . tTbxList * msgBuffer; void MsgBufferInit(void) { /* Create the linked list. */ msgBuffer = TbxListCreate(); /* Create message memory pool with an initial size of 1. */ TbxMemPoolCreate(1, sizeof(tMsg)); } void MsgBufferAdd(tMsg const * msg) { tMsg * newMsg; /* Attempt to allocate memory to store the message. */ newMsg = TbxMemPoolAllocate(sizeof(tMsg)); /* Automatically increase the memory pool if it was too small. */ if (newMsg == NULL) { TbxMemPoolCreate(1, sizeof(tMsg)); newMsg = TbxMemPoolAllocate(sizeof(tMsg)); } /* Copy the message. */ *newMsg = *msg; /* Add the message at the end of the list. */ TbxListInsertItemBack(msgBuffer, newMsg); } uint8_t MsgBufferGet(tMsg * msg) { uint8_t result = TBX_ERROR; tMsg * oldMsg; uint8_t idx; /* Get the oldest message from the list, if any. */ oldMsg = TbxListGetFirstItem(msgBuffer); if (oldMsg != NULL) { /* Delete it from the list now that we read it. */ TbxListRemoveItem(msgBuffer, oldMsg); /* Copy the message contents. */ *msg = *oldMsg; /* Give the allocated memory for the message back to the pool. */ TbxMemPoolRelease(oldMsg); /* Update the result. */ result = TBX_OK; } return result; } You now not only have a FIFO buffer for storing messages, but its implementation is such that it can automatically grow in size. Memory pools form the foundation for this, meaning that you do not have to worry about memory fragmentation. The following code demonstrates how messages can be stored and retrieved from this FIFO buffer: /* Initialize the message FIFO buffer. */ MsgBufferInit(); /* Add a few messages. */ tMsg newMsg1 = { 0x200, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; tMsg newMsg2 = { 0x300, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; tMsg newMsg3 = { 0x100, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; MsgBufferAdd(&newMsg1); MsgBufferAdd(&newMsg2); MsgBufferAdd(&newMsg3); /* Extract messages from the FIFO buffer. */ tMsg msg; while (MsgBufferGet(&msg) == TBX_OK) { printf(\" Item ID: 0x%x\\n\", msg.id); } After running this code, the following is shown: Item ID: 0x200 Item ID: 0x300 Item ID: 0x100","title":"Example 1"},{"location":"lists/#example-2","text":"The second example demonstrates how to iterate through contents of a linked list. The following function prints information about the list contents: void MsgBufferPrint(void) { tMsg * msg; size_t cnt = 0; printf(\"Number of items: %d\\n\", TbxListGetSize(msgBuffer)); msg = TbxListGetFirstItem(msgBuffer); while (msg != NULL) { printf(\" Item %d ID: 0x%x\\n\", ++cnt, msg->id); msg = TbxListGetNextItem(msgBuffer, msg); } } After running this example code: /* Initialize the message FIFO buffer. */ MsgBufferInit(); /* Add a few messages. */ tMsg newMsg1 = { 0x200, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; tMsg newMsg2 = { 0x300, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; tMsg newMsg3 = { 0x100, 8, { 1, 2, 3, 4, 5, 6, 7, 8} }; MsgBufferAdd(&newMsg1); MsgBufferAdd(&newMsg2); MsgBufferAdd(&newMsg3); /* Print current FIFO buffer contents. */ MsgBufferPrint(); The following is shown: Number of items: 3 Item 1 ID: 0x200 Item 2 ID: 0x300 Item 3 ID: 0x100","title":"Example 2"},{"location":"lists/#example-3","text":"The third example builds upon example 2, where there are three messages in the list. Let's assume you want to sort the list contents based on the message identifier. For this you could implement the following function for comparing two messages: uint8_t CompareMessage(void const * item1, void const * item2) { uint8_t result = TBX_FALSE; tMsg const * msg1 = item1; tMsg const * msg2 = item2; if (msg1->id > msg2->id) { result = TBX_TRUE; } return result; } To perform the actual sort operation, you could run this code: /* Print FIFO buffer contents before sorting. */ printf(\"--- Before sorting ---\\n\"); MsgBufferPrint(); /* Sort the buffer based on the message identifier. */ TbxListSortItems(msgBuffer, CompareMessage); /* Print FIFO buffer contents after sorting. */ printf(\"--- After sorting ---\\n\"); MsgBufferPrint(); The following is shown: --- Before sorting --- Number of items: 3 Item 1 ID: 0x200 Item 2 ID: 0x300 Item 3 ID: 0x100 --- After sorting --- Number of items: 3 Item 1 ID: 0x100 Item 2 ID: 0x200 Item 3 ID: 0x300 Note that the items in the list are now sorted based on the message identifier in ascending order.","title":"Example 3"},{"location":"lists/#configuration","text":"The linked list software component itself does not have to be configured. However, when creating a linked list and inserting items into it, the memory needed is dynamically allocated with the help of a memory pool. Because a memory pool takes memory from the heap, make sure the heap size is configured large enough with the help of macro TBX_CONF_HEAP_SIZE : /** \\brief Configure the size of the heap in bytes. */ #define TBX_CONF_HEAP_SIZE (2048U)","title":"Configuration"},{"location":"mempools/","text":"Dynamic memory allocation with the help of a memory pool is required for data that has a lifetime longer than just one function, yet shorter than the run-time of the entire software program. This is typically the case in event driven software. Take for example an embedded software program that communicates via CAN. When a CAN message reception interrupt triggers, the contents of the newly received CAN message are typically stored somewhere for later processing at task level. In this case data storage for the CAN message can be dynamically allocated and freed when it is no longer needed. The C standard library functions malloc() and free() can unfortunately not be used for this in a RAM constrained microcontroller based system. Both functions treat the heap as a byte pool, which means there is always a fragmentation risk present. This risk is unacceptable for an embedded software program. Note that if dynamic memory allocation is needed, where the lifetime of the allocated data equals the run-time of the entire software program, it is better to use the method of static memory preallocation with the help of the heap software component. The heap software component is also a part of MicroTBX. Each memory pool consists of a run-time configurable amount of fixed-sized data blocks. The software program has full control over how many memory pools it creates and how many bytes the data blocks. Usage A prerequisite to performing dynamic memory allocation, is that the software program first creates one or more memory pools. Function TbxMemPoolCreate() creates a memory pool. Through the function parameters you can specify the number of bytes for each data block inside the pool and how many data blocks it should hold. It is recommended to create the memory pools during the software program initialization, before the infinite program loop is entered. However, it is safe to create memory pools at any point in the software program. Note that if you attempt to create a memory pool with a data block size that already exists, the memory pools software component is smart enough to extend the already existing memory pool, instead of creating a new one. The trick is to tune the memory pools to your specific software program needs. When unsure about the what memory pools to create, it is a good starting point to create memory pools with sizes that are powers of two. For example, 8, 16, 32, 64, 128, etc. Once the memory pools are created, memory allocation with the memory pool software component is actually quite similar to calling the C standard library functions. To allocate memory, call TbxMemPoolAllocate() instead of malloc() . The best fitting memory pool for the data size requested, is automatically selected. Once the allocated data is no longer needed, call TbxMemPoolRelease() , instead of free() . Examples The following example program demonstrates how memory pools are created and proves that data from the memory pools can be dynamically allocated and released over and over again. It it also an example of how you can expand and existing memory pool at a later point in time. void main(void) { size_t idx; uint8_t * dataPtr[16]; uint8_t firstLoop = TBX_TRUE; /* Create 2 memory pools with block sizes 16 and 32 that have 8 * data blocks per pool. */ TbxMemPoolCreate(8U, 16U); TbxMemPoolCreate(8U, 32U); /* Not actually used in this example. */ /* Enter the infinite program loop. */ for (;;) { /* Allocate all blocks in the memory pool with size 16. A smaller * block size (12 in this case) is automatically matched to the * memory pool with the next size up (16 in this case). */ for (idx = 0U; idx < 8U; idx++) { dataPtr[idx] = TbxMemPoolAllocate(12U); TBX_ASSERT(dataPtr[idx] != NULL); } /* Note that when the memory pool with block sizes of 16 bytes is * exhausted, the memory pool module does NOT automatically switch * to a memory pool with larger sized blocks. This was done on * purpose by design. * * The reason for this is that it is now possible to expand an * existing memory pool when it is full. Assume a situation where * all blocks in the memory pool are already allocated. The next * call to TbxMemPoolAllocate() therefore fails. You could now * call TbxMemPoolCreate() again for the same block size and the * original memory pool is expanded automatically. * * This is actually a very powerful feature, as it enables you * to dynamically enlarge the memory pool whenever needed, * provided the heap is configured to be large enough. A * simplified demonstration of this follows here. */ if (firstLoop == TBX_TRUE) { /* Reset the flag because this part should only execute during * the first loop iteration. */ firstLoop = TBX_FALSE; /* During the first loop iteration, the next allocation should * fail because all 8 blocks in the memory pool with size 16 * are already allocated. */ TBX_ASSERT(TbxMemPoolAllocate(16U) == NULL); /* Now expand the memory pool with block size 16 to add * another 8 blocks. */ TbxMemPoolCreate(8U, 16U); } /* The memory pool with block size of 16 should now have 16 * blocks. 8 were allocated, so it should be possible to * allocate another 8. */ for (idx = 8U; idx < 16U; idx++) { dataPtr[idx] = TbxMemPoolAllocate(12U); TBX_ASSERT(dataPtr[idx] != NULL); } /* The memory pool with block size of 16 should now be * exhausted and it should therefore not be possible * to allocate another block it in. Let's test this. */ TBX_ASSERT(TbxMemPoolAllocate(16U) == NULL); /* Now release all the allocated data blocks again. */ for (idx = 0U; idx < 16U; idx++) { TbxMemPoolRelease(dataPtr[idx]); } } } Configuration The memory pool software component itself does not have to be configured. However, when creating memory pools with function TbxMemPoolCreate() , the data blocks are statically preallocated on the heap with the help of the heap module. In case the memory pool creation fails, it is likely that the heap size needs to be increased using the macro TBX_CONF_HEAP_SIZE : /** \\brief Configure the size of the heap in bytes. */ #define TBX_CONF_HEAP_SIZE (2048U)","title":"Memory Pools"},{"location":"mempools/#usage","text":"A prerequisite to performing dynamic memory allocation, is that the software program first creates one or more memory pools. Function TbxMemPoolCreate() creates a memory pool. Through the function parameters you can specify the number of bytes for each data block inside the pool and how many data blocks it should hold. It is recommended to create the memory pools during the software program initialization, before the infinite program loop is entered. However, it is safe to create memory pools at any point in the software program. Note that if you attempt to create a memory pool with a data block size that already exists, the memory pools software component is smart enough to extend the already existing memory pool, instead of creating a new one. The trick is to tune the memory pools to your specific software program needs. When unsure about the what memory pools to create, it is a good starting point to create memory pools with sizes that are powers of two. For example, 8, 16, 32, 64, 128, etc. Once the memory pools are created, memory allocation with the memory pool software component is actually quite similar to calling the C standard library functions. To allocate memory, call TbxMemPoolAllocate() instead of malloc() . The best fitting memory pool for the data size requested, is automatically selected. Once the allocated data is no longer needed, call TbxMemPoolRelease() , instead of free() .","title":"Usage"},{"location":"mempools/#examples","text":"The following example program demonstrates how memory pools are created and proves that data from the memory pools can be dynamically allocated and released over and over again. It it also an example of how you can expand and existing memory pool at a later point in time. void main(void) { size_t idx; uint8_t * dataPtr[16]; uint8_t firstLoop = TBX_TRUE; /* Create 2 memory pools with block sizes 16 and 32 that have 8 * data blocks per pool. */ TbxMemPoolCreate(8U, 16U); TbxMemPoolCreate(8U, 32U); /* Not actually used in this example. */ /* Enter the infinite program loop. */ for (;;) { /* Allocate all blocks in the memory pool with size 16. A smaller * block size (12 in this case) is automatically matched to the * memory pool with the next size up (16 in this case). */ for (idx = 0U; idx < 8U; idx++) { dataPtr[idx] = TbxMemPoolAllocate(12U); TBX_ASSERT(dataPtr[idx] != NULL); } /* Note that when the memory pool with block sizes of 16 bytes is * exhausted, the memory pool module does NOT automatically switch * to a memory pool with larger sized blocks. This was done on * purpose by design. * * The reason for this is that it is now possible to expand an * existing memory pool when it is full. Assume a situation where * all blocks in the memory pool are already allocated. The next * call to TbxMemPoolAllocate() therefore fails. You could now * call TbxMemPoolCreate() again for the same block size and the * original memory pool is expanded automatically. * * This is actually a very powerful feature, as it enables you * to dynamically enlarge the memory pool whenever needed, * provided the heap is configured to be large enough. A * simplified demonstration of this follows here. */ if (firstLoop == TBX_TRUE) { /* Reset the flag because this part should only execute during * the first loop iteration. */ firstLoop = TBX_FALSE; /* During the first loop iteration, the next allocation should * fail because all 8 blocks in the memory pool with size 16 * are already allocated. */ TBX_ASSERT(TbxMemPoolAllocate(16U) == NULL); /* Now expand the memory pool with block size 16 to add * another 8 blocks. */ TbxMemPoolCreate(8U, 16U); } /* The memory pool with block size of 16 should now have 16 * blocks. 8 were allocated, so it should be possible to * allocate another 8. */ for (idx = 8U; idx < 16U; idx++) { dataPtr[idx] = TbxMemPoolAllocate(12U); TBX_ASSERT(dataPtr[idx] != NULL); } /* The memory pool with block size of 16 should now be * exhausted and it should therefore not be possible * to allocate another block it in. Let's test this. */ TBX_ASSERT(TbxMemPoolAllocate(16U) == NULL); /* Now release all the allocated data blocks again. */ for (idx = 0U; idx < 16U; idx++) { TbxMemPoolRelease(dataPtr[idx]); } } }","title":"Examples"},{"location":"mempools/#configuration","text":"The memory pool software component itself does not have to be configured. However, when creating memory pools with function TbxMemPoolCreate() , the data blocks are statically preallocated on the heap with the help of the heap module. In case the memory pool creation fails, it is likely that the heap size needs to be increased using the macro TBX_CONF_HEAP_SIZE : /** \\brief Configure the size of the heap in bytes. */ #define TBX_CONF_HEAP_SIZE (2048U)","title":"Configuration"},{"location":"misra/","text":"Static code analysis was performed to verify compliance with MISRA-C 2012. The following table lists the compliance exceptions: Directive Type Rationale 4.9 advisory Function-like macros can provide clarity and allow easy to understand compile time configurations. 11.5 advisory Conversions from pointer to void to pointer to other type. This is needed after allocating memory from the heap and then initialising a pointer to point to this allocated memory. Used for example when allocating memory to build a linked list.","title":"MISRA Compliance"},{"location":"random/","text":"The random number generator software component offers functionality for generating 32-bit random numbers. The generator algorithm is based on the linear feedback shift register approach ( LFSR ), specifically the one presented in application note 4400 from Maxim Integrated. Usage Whenever a random number is to be obtained, call function TbxRandomNumberGet() . The internal generator algorithm needs to be properly seeded. By default, the same constant value is assigned to the seed. This means that each time function TbxRandomNumberGet() is called, you get a different number, but the consecutive numbers will always be the same each time your program is restarted: Reset #1 Reset #2 Reset #3 3196210335 3196210335 3196210335 2375684060 2375684060 2375684060 3691277220 3691277220 3691277220 3596136368 3596136368 3596136368 For some applications, this behavior is acceptable. However, most applications require different random numbers to be generated each time the software program is started. This is achieved by calling TbxRandomSetSeedInitHandler() to register your own seed initialization function. The ideal implementation of your seed initialization function is such that it returns a different seed value, each time the software program is newly started. Here are some possible approaches to realize such a changing seed value: Keep one of the analog inputs on your microcontroller unconnected. Such a floating analog input picks up noise from the surrounding environment and readings will therefore always vary slightly. Configure your ADC peripheral to perform an analog to digital conversion of this analog input and use its result value to seed the generator. If your microcontroller has EEPROM or a non-volatile register, you can use it to store a value that you use to seed the generator. Then simply increment its value by one upon software program startup. This way you have a different seed value every time your software program is started. Keep in mind though that these data storage options have a limited amount of write cycles. A better option might be to use external FRAM. If your microcontroller has access to an external file system such as an SD-card, you could store a value, which you use to seed the generator, in a file. Then simply increment its value by one upon software program startup. This way you have a different seed value every time your software program is started. If your microcontroller based system features a battery backed real-time clock, you could use the current date/time value to seed the generator algorithm. Here are the results of a demo program that implements method (1) with the floating analog input to seed the generator algorithm: Reset #1 Reset #2 Reset #3 1193105914 99986390 2131584566 3607630837 1266123007 2093232 2184628642 3493368727 1164981103 793839531 296055939 3318979929 Examples To generate a new random number, call the function RandomNumberGet() and it will return a new 32-bit random number. Example: uint32_t number; /* Generate a new random number. */ number = TbxRandomNumberGet(); The following function is an example implementation of an application specific seed initialization. It is based on the above described method (1) where a floating analog input provides randomness upon each read of the analog pin: uint32_t CustomSeedInitHandler(void) { /* Create a 32-bit seed value by combining two reads of the floating analog * pin. */ return (AnalogFloatGet() << 16u) | AnalogFloatGet(); } The above example assumes that the application provides the function AnalogFloatGet() for performing an analog to digital conversion of the analog input pin that is left floating. To register the function CustomSeedInitHandler() with the random number generator software component, make the following function call during the initialization of your software program: /* Register application specific seed initialization function. */ TbxRandomSetSeedInitHandler(CustomSeedInitHandler);","title":"Random Numbers"},{"location":"random/#usage","text":"Whenever a random number is to be obtained, call function TbxRandomNumberGet() . The internal generator algorithm needs to be properly seeded. By default, the same constant value is assigned to the seed. This means that each time function TbxRandomNumberGet() is called, you get a different number, but the consecutive numbers will always be the same each time your program is restarted: Reset #1 Reset #2 Reset #3 3196210335 3196210335 3196210335 2375684060 2375684060 2375684060 3691277220 3691277220 3691277220 3596136368 3596136368 3596136368 For some applications, this behavior is acceptable. However, most applications require different random numbers to be generated each time the software program is started. This is achieved by calling TbxRandomSetSeedInitHandler() to register your own seed initialization function. The ideal implementation of your seed initialization function is such that it returns a different seed value, each time the software program is newly started. Here are some possible approaches to realize such a changing seed value: Keep one of the analog inputs on your microcontroller unconnected. Such a floating analog input picks up noise from the surrounding environment and readings will therefore always vary slightly. Configure your ADC peripheral to perform an analog to digital conversion of this analog input and use its result value to seed the generator. If your microcontroller has EEPROM or a non-volatile register, you can use it to store a value that you use to seed the generator. Then simply increment its value by one upon software program startup. This way you have a different seed value every time your software program is started. Keep in mind though that these data storage options have a limited amount of write cycles. A better option might be to use external FRAM. If your microcontroller has access to an external file system such as an SD-card, you could store a value, which you use to seed the generator, in a file. Then simply increment its value by one upon software program startup. This way you have a different seed value every time your software program is started. If your microcontroller based system features a battery backed real-time clock, you could use the current date/time value to seed the generator algorithm. Here are the results of a demo program that implements method (1) with the floating analog input to seed the generator algorithm: Reset #1 Reset #2 Reset #3 1193105914 99986390 2131584566 3607630837 1266123007 2093232 2184628642 3493368727 1164981103 793839531 296055939 3318979929","title":"Usage"},{"location":"random/#examples","text":"To generate a new random number, call the function RandomNumberGet() and it will return a new 32-bit random number. Example: uint32_t number; /* Generate a new random number. */ number = TbxRandomNumberGet(); The following function is an example implementation of an application specific seed initialization. It is based on the above described method (1) where a floating analog input provides randomness upon each read of the analog pin: uint32_t CustomSeedInitHandler(void) { /* Create a 32-bit seed value by combining two reads of the floating analog * pin. */ return (AnalogFloatGet() << 16u) | AnalogFloatGet(); } The above example assumes that the application provides the function AnalogFloatGet() for performing an analog to digital conversion of the analog input pin that is left floating. To register the function CustomSeedInitHandler() with the random number generator software component, make the following function call during the initialization of your software program: /* Register application specific seed initialization function. */ TbxRandomSetSeedInitHandler(CustomSeedInitHandler);","title":"Examples"}]}